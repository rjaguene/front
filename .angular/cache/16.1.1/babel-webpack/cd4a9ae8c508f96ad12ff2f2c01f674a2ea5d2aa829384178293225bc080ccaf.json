{"ast":null,"code":"var __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = this && this.__metadata || function (k, v) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar _a;\nimport { Component, ElementRef, HostListener } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport { Router } from '@angular/router';\nexport let LoginPageComponent = class LoginPageComponent {\n  constructor(elementRef, http, router) {\n    this.elementRef = elementRef;\n    this.http = http;\n    this.router = router;\n  }\n  ngOnInit() {\n    this.canvas = this.elementRef.nativeElement.querySelector('#background');\n    this.ctx = this.canvas.getContext('2d');\n    this.canvas.width = window.innerWidth;\n    this.canvas.height = window.innerHeight;\n    this.backgroundAnimation();\n  }\n  login() {\n    this.http.post('/api/login', {\n      username: this.username,\n      password: this.password\n    }).subscribe(response => {\n      console.log(response);\n      if (response['status'] === 'success') {\n        this.router.navigate(['/dash']);\n      }\n    }, error => {\n      if (error.status === 401) {\n        // Authentification failed\n        window.alert('Erreur d\\'authentification. Veuillez vérifier votre nom d\\'utilisateur et mot de passe.');\n      } else {\n        // Other errors\n        console.error(error);\n      }\n    });\n  }\n  onResize(event) {\n    this.canvas.width = event.target.innerWidth;\n    this.canvas.height = event.target.innerHeight;\n  }\n  backgroundAnimation() {\n    const particles = [];\n    const numParticles = 600;\n    class Particle {\n      constructor(x, y) {\n        this.x = x;\n        this.y = y;\n        this.size = Math.random() * 0.5 + 0.5;\n        this.speedX = Math.random() * 2 - 1.5;\n        this.speedY = Math.random() * 2 - 1.5;\n      }\n      update(canvasWidth, canvasHeight) {\n        this.x += this.speedX;\n        this.y += this.speedY;\n        // Vérifie si la particule est hors de l'écran et la replace de l'autre côté\n        if (this.x < 0) {\n          this.x = canvasWidth;\n        } else if (this.x > canvasWidth) {\n          this.x = 0;\n        }\n        if (this.y < 0) {\n          this.y = canvasHeight;\n        } else if (this.y > canvasHeight) {\n          this.y = 0;\n        }\n      }\n      draw(ctx) {\n        //console.log('Drawing particle:', this);\n        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';\n        ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';\n        ctx.lineWidth = 2;\n        ctx.beginPath();\n        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);\n        ctx.closePath();\n        ctx.fill();\n        ctx.stroke();\n      }\n    }\n    const connectParticles = () => {\n      const particlesDistance = 100;\n      for (let a = 0; a < numParticles; a++) {\n        for (let b = a; b < numParticles; b++) {\n          if (particles[a] && particles[b]) {\n            // Ajout de cette ligne pour vérifier si les particules existent\n            const dx = particles[a].x - particles[b].x;\n            const dy = particles[a].y - particles[b].y;\n            const distance = Math.sqrt(dx * dx + dy * dy);\n            if (distance < particlesDistance) {\n              this.ctx.beginPath();\n              this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';\n              this.ctx.lineWidth = 1.5;\n              this.ctx.moveTo(particles[a].x, particles[a].y);\n              this.ctx.lineTo(particles[b].x, particles[b].y);\n              this.ctx.stroke();\n              this.ctx.closePath();\n            }\n          }\n        }\n      }\n    };\n    const initParticles = () => {\n      for (let i = 0; i < numParticles; i++) {\n        const x = Math.random() * this.canvas.width;\n        const y = Math.random() * this.canvas.height;\n        particles.push(new Particle(x, y));\n      }\n    };\n    const animateParticles = () => {\n      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n      let particlesToRemove = [];\n      for (let particle of particles) {\n        particle.update(this.canvas.width, this.canvas.height); // Ajout des paramètres\n        particle.draw(this.ctx);\n        if (particle.size <= 0.2) {\n          particlesToRemove.push(particle);\n        }\n      }\n      for (let particle of particlesToRemove) {\n        const index = particles.indexOf(particle);\n        if (index !== -1) {\n          particles.splice(index, 1);\n        }\n      }\n      connectParticles();\n      requestAnimationFrame(animateParticles);\n    };\n    initParticles();\n    animateParticles();\n  }\n};\n__decorate([HostListener('window:resize', ['$event']), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object]), __metadata(\"design:returntype\", void 0)], LoginPageComponent.prototype, \"onResize\", null);\nLoginPageComponent = __decorate([Component({\n  selector: 'app-login-page',\n  templateUrl: './login-page.component.html',\n  styleUrls: ['./login-page.component.css']\n}), __metadata(\"design:paramtypes\", [ElementRef, typeof (_a = typeof HttpClient !== \"undefined\" && HttpClient) === \"function\" ? _a : Object, Router])], LoginPageComponent);","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}